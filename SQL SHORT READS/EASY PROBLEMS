Problem 1
Retrieve all employee’s first names from the employees table.

SELECT e.first_name
FROM employees as e;


Problem 2
Retrieve the employee ID, hire date, and the job ID for each employee.

SELECT e.employee_id, e.hire_date, e.job_id
FROM employees as e;


Problem 3
Retrieve the department ID, department name, manager ID, and location ID for each department.

SELECT *
FROM department;


Problem 4
Retrieve all employee IDs. Rename this column to read as “worker_id.”

SELECT e.employee_id AS worker_id
FROM employees AS e;


Problem 5
For each job, retrieve the job code, job title, minimum salary, and maximum salary. Rename these columns to read as job_code, title, minimum_salary, and maximum_salary, respectively.

SELECT j.job_id AS job_code, j.job_title AS title, j.min_salary AS minimum_salary, j.max_salary AS maximum_salary
FROM jobs AS j;


Problem 6: Retrieve the job ID, job title, maximum salary, minimum salary, and salary range for each job. Salary range is defined as the difference between the maximum salary and minimum salary. Alias the difference as “salary_range.”

SELECT j.job_id , j.job_title , j.min_salary, j.max_salary, j.max_salary-j.min_salary AS salary_range
FROM jobs AS j;


Problem 7
Retrieve the country id and country name for each country.

SELECT DISTINCT c.country_id, c.country_name 
FROM countries;


Problem 8
Retrieve the employee ID, email, and phone number for each employee.

SELECT e.employee_id, e.email, e.phone_number
FROM employees AS e;


Problem 9
Retrieve the job ID, job title, and minimum salary for each job at the company.

SELECT j.job_id,	j.job_title, j.min_salary
FROM jobs AS j;


Problem 10
Retrieve the location ID, city, and state/province for all warehouse/department locations.

SELECT l.location_id, l.city, l.state_province
FROM locations AS l;


Problem 11
Retrieve the location ID, street address, city, and state/province for departments or warehouses located in Texas.

Solution:
SELECT l.location_id,	l.street_address, l.city, l.state_province
FROM locations AS l
WHERE l.state_province = 'Texas';


Problem 12
Retrieve the employee ID, job ID, and hire date for employees hired in year 2007 or later.

SELECT e.employee_ID, e.job ID, e.hire_date
FROM employees AS e
WHERE e.hire_date>= '2007';


Problem 13
Retrieve the department ID, department name, and location ID for departments/warehouses with location IDs other than 1700.

SELECT d.department _ID, d.department_name, and d.location_ID
FROM departments AS d
WHERE d.location_ID != '1700' ;


Problem 14
Retrieve the employee ID, first name, last name, and job ID for each programmer (i.e., those employees with a job ID of “IT_PROG.”

SELECT e.employee_ID, e.first_name, e.last_name, e.job_ID
FROM employees as e
WHERE e.job_ID='IT_PROG' ;


Problem 15
Retrieve the location ID, city, and state/province, and country ID for department/warehouse locations outside of the United States.

SELECT l.Location_id, l.city, l.state_province, l.country_id
FROM locations AS l
WHERE l.country_id != 'US' ;


Problem 16
Retrieve the employee ID, job ID, and salary for employees with a salary of greater than or equal to $10,000.

SELECT e.employee_id, e.job_id, e.salary 
FROM employees AS e
WHERE e.salary >= 10000 ;


Problem 17
Retrieve the location ID, city, state/province, and country ID for department/warehouse locations in the United States or Canada.

SELECT l.location_id, l.city, l.state_province, l.country_id
FROM locations AS l
WHERE l.country_id ='US' OR l.country_id='CA' ;

ALternate Answer: SELECT l.location_id, l.city, l.state_province, l.country_id
FROM locations AS l
WHERE l.country_id IN ('US','CA'); 



Problem 18
Retrieve the location ID, city, state/province, and country ID for department/warehouse locations outside the United States and Canada.

SELECT l.location_id, l.city, l.state_province, l.country_id
FROM locations AS l
WHERE l.country_id NOT IN ('US' , 'CA') ;


Problem 19
Retrieve the employee ID and salary for all associates with a salary between $6,000 and $10,000, inclusive.

SELECT e.employee_id, e.salary 
FROM employees AS e
WHERE e.salary BETWEEN 6000 AND 10000;


Problem 20
Retrieve the employee ID, first name, last name, job ID, hire date, and salary for all employees hired between 2004 and 2006, inclusive.

SELECT e.employee_id, e.frist_name, e.last_name, e.hire_date, e.salary 
FROM employees as e
WHERE e.hire_date BETWEEN '01-JAN-2004' AND '31-DEC-2006' ;


Problem 21
Retrieve the employee ID, job ID, and salary for employees with job IDs other than IT_PROG, SA_MAN, and PU_CLERK.

SELECT e.employee_id, e.job_id, e.salary 
FROM employees AS e
WHERE e.job_id NOT IN ('IT_PROG' , 'SA_MAN', 'PU_CLERK');


Problem 22
Retrieve the employee ID, job ID, hire date, and salary for employees with salaries between $15,000 and $30,000, inclusive.

SELECT e.employee_id, e.job_id, e.hire_date, e.salary 
FROM employees AS e
WHERE e.salary BETWEEN 15000 AND 30000;


Problem 23
Retrieve the employee ID and first names of employees with a first name starting with the letter ‘A.’

SELECT e.employee_id, e.first_name
FROM employees AS e
WHERE e.first_name LIKE 'A%';


Problem 24
Retrieve the employee ID and first names of employees with a first name starting with the letter ‘C’ followed by any sequence of characters and ending with the letter ‘s.’
SELECT e.employee_id, e.first_name
FROM employees AS e
WHERE e.first_name LIKE 'C%s';


Problem 25
Retrieve employee phone numbers where the first digit is a 5, 3rd to last digit is a 1, second to last digit is any number, and the final digit is a 9.

SELECT e.phone_number
FROM employees AS e
WHERE e.phone_number LIKE '5%1_9' ; 


Problem 26
Retrieve the employee ID and last name of employees with a last name not starting with the letter ‘B.’

SELECT e.employee_id, e.last_name
FROM employees AS e
WHERE e.last_name NOT LIKE 'B%' ;


Problem 27
Retrieve all employee IDs for employees with a phone number containing the sequence of digits, 423.

SELECT e.employee_id 
FROM employees AS e
WHERE e.phone_number LIKE '%423%' ; 


Problem 28
Retrieve the employee ID and job ID for those employees with job IDs starting with the letters ‘AD.’

SELECT e.employee_id, e.job_id
FROM employees AS e 
WHERE e.job_id LIKE 'AD%' ; 


Problem 29
Retrieve the employee ID and salary for employees with a salary starting with the 1 digit followed by a single digit of any value and ending with 3 zeros (e.g., 14000).

SELECT e.employee_id, e.salary
FROM employees AS e
WHERE e.salary LIKE '1_000';


Problem 30
Retrieve the country ID and country name for country names starting with ‘A’ and ending in ‘a.’
SELECT c.country_id, c.country_name
FROM countries AS c
WHERE c.country_name LIKE 'A%a';


Problem 31
Retrieve the employee ID and phone number of employees where the phone number doesn’t begin with ‘650.’

SELECT e.employee_id,e.phone_number
FROM employees AS e
WHERE e.phone_number NOT LIKE '650%';


Problem 32
Retrieve the department ID, department name, and manager ID for departments without a manager ID assigned.

SELECT d.department_id, d.department_name, d.manager_id 
FROM departments AS d
WHERE d.manager_id IS NULL;


Problem 33
Retrieve the department ID, department name, and manager ID for departments with a manager ID assigned.

SELECT d.department_id, d.department_name, d.manager_id
FROM departments AS d
WHERE d.manager_id IS NOT NULL;


Problem 34
Retrieve the employee ID and commission percentage for those employees with existing commission percentages

SELECT e.employee_id, e.commission_pct
FROM employees AS e
WHERE e.commission_pct IS NOT NULL;


Problem 35
Retrieve the employee ID and commission percentage for those employees with non-existing commission percentages.

SELECT e.employee_id, e.commission_pct
FROM employees AS e
WHERE e.commission_pct IS NULL ;


Problem 36
Retrieve the employee ID, job ID, salary, and manager ID for all employees with a manager ID of 100 or 108 and a salary greater than $12,000.

SELECT e.employee_id, e.job_id, e.manager_id, e.salary 
FROM employees AS e
WHERE e.salary>12000 AND e.manager_id IN (100,108);


Problem 37
Retrieve the job ID, job title, minimum salary, and maximum salary for management jobs or those jobs with a minimum salary greater than 20,000 and a maximum salary greater than 25,000.

SELECT j.job_id, j.job_title,	j.min_salary,	j.max_salary
FROM jobs AS j
WHERE j.job_title LIKE '%Manager%' OR (j.min_salary>20000 AND j.max_salary>25000) ;


Problem 38
Retrieve the employee ID, job ID, and department ID employees for employees that meet one or more of the following conditions:
Department ID is equal to 90 and the job ID is equal to ‘AD_PRES’
Department ID is equal to 100 and the job ID is equal to ‘FI_ACCOUNT’
Employee ID is equal to 115

SELECT e.employee_id, e.job_id, e.department _id
FROM employees AS e
WHERE (e.department _id=90 AND e.job_id =‘AD_PRES’) OR 
      (e.department _id=100 AND e.job_id =‘FI_ACCOUNT’) OR 
       e.employee_id=115 ;                                          * *assuming 115 is not string. 


Problem 39
Retrieve the employee ID, hire date, job ID, and salary for employees hired on as programmers in year 2007.

SELECT e.employee_id, e.hire_date, e.job_id, e.salary
FROM employees AS e
WHERE YEAR(e.hire_date) = 2007 AND e.job_id='IT_PROG' ; 


Problem 40
Retrieve the employee ID, hire date, job ID, and salary for employees that were hired on as programmers or in the year 2007.

SELECT e.employee_id, e.hire_date, e.job_id, e.salary
FROM employees AS e
WHERE YEAR(e.hire_date)=2007 OR e.job_id='IT_PROG';


Problem 41
Retrieve the employee ID, hire date, job ID, and salary for employees that were hired in year 2007 or were hired on as programmers with a salary greater than 5000.

SELECT e.employee_id, e.hire_date, e.job_id, e.salary
FROM employees AS e
WHERE YEAR(e.hire_date)=2007 OR (e.job_id='IT_PROG' AND e.salary>5000);


Problem 42
Retrieve the employee ID, hire date, job ID, manager ID, and salary for employees that were hired in year 2007 or were hired on as programmers with a salary greater than 5000 or employees without a manager ID assigned and with a salary greater than 5000.


SELECT e.employee_id, e.hire_date, e.job_id, e.salary 
FROM employees AS e
WHERE YEAR(e.hire_date)=2007 OR 
          (e.job_id='IT_PROG' AND e.salary>5000) OR 
          (e.manager_id IS NULL AND e.salary > 5000); 


Problem 43
Retrieve the minimum salary, maximum salary, average salary, and total sum of salaries. Provide appropriate aliases for the aggregations.

SELECT MIN(e.salary) AS minimum_salary,
       MAX(e.salary) AS maximum_salary,
       AVG(e.salary) AS average_salary,
       SUM(e.salary) AS total_salary
FROM employees AS e;


Problem 44
For each job ID, compute the average employee salary with respect to the job ID. Provide an appropriate alias for the aggregation.

SELECT e.job_id, AVG(e.salary) AS average_salary
FROM employees AS e
GROUP BY e.job_id;


Problem 45
For each job ID, compute the minimum and maximum salary with respect to the job ID. Provide appropriate aliases for the aggregations.

SELECT e.job_id, MIN(e.salary) AS minimum_salary, MAX(e.salary) AS maximum_salary
FROM employees AS e
GROUP BY job_id;


Problem 46
For each existing job ID and manager ID combination, compute the number of employees and the average salary for those employees. Provide appropriate aliases for the aggregations.

SELECT e.job_id, e.manager_id, AVG(e.salary) AS average_salary, COUNT(e.salary) AS employee_count
FROM employees AS e
GROUP BY e.job_id,e.manager_id;


Problem 47
For each region ID, compute the number of countries assigned the region ID. Provide an appropriate alias for the aggregation.

SELECT c.region_id, COUNT(c.country_name) AS number_of_countries
FROM countries AS c
GROUP BY c.region_id; 


Problem 48
For each manager ID, compute the number of employees assigned the manager ID. Provide an appropriate alias for the aggregation.

SELECT e.manager_id, COUNT(e.employee_id) AS employee_count
FROM employees AS e 
GROUP BY e.manager_id;


Problem 49
For each manager ID, compute the maximum salary for employees assigned the manager ID. Provide an appropriate alias for the aggregation.

SELECT e.manager_id, MAX(e.salary) AS maximum_salary_of_employee
FROM employees AS e
GROUP BY e.manager_id;


Problem 50
For each country ID and state/province combination, compute the number of department/warehouse locations. Provide an appropriate alias for the aggregation.

SELECT l.country_id, l.state_province, COUNT(l.location_id) AS location_count
FROM locations AS l
GROUP BY l.country_id, l.state_province;


Problem 51
For each job ID, compute the minimum and maximum salary with respect to the job ID. Return only job IDs with an range (MAX Salary – MIN Salary for each job ID) of salaries greater than or equal to $3,000. Provide appropriate aliases for the aggregations.

SELECT e.job_id, MAX(e.salary) AS max_salary, MIN(e.salary) AS min_salary
FROM employees AS e
GROUP BY job_id
HAVING (MAX(e.salary)- MIN(e.salary)) >= 3000 ;


Problem 52
For each existing job ID and manager ID combination, compute the number of employees and the average salary for those employees. Return only those job ID and manager ID combinations for which at least two employees are employed under the respective job ID and manager ID combination. Provide appropriate aliases for the aggregations.

SELECT e.job_id, e.manager_id, COUNT(e.employee_id) AS employee_count, AVG(e.salary) AS average_salary
FROM employees AS e
GROUP BY e.job_id, e.manager_id
HAVING COUNT(e.employee_id) >=2; 


Problem 53
Retrieve the department ID(s) and the sum of the employees’ salaries for each department ID for departments with a total salary of greater than $100,000. Provide an appropriate alias for the aggregation.

SELECT e.department_id, SUM(e.salary) AS total_department_salary
FROM employees AS e
GROUP BY e.department_id
HAVING SUM(e.salary) > 100000; 


Problem 54
Retrieve the department IDs and the number of employees where more than 5 employees are assigned/work in. Provide an appropriate alias for the aggregation.

SELECT e.department_id, COUNT(e.employee_id) AS employee_count
FROM employees AS e
GROUP BY e.department_id
HAVING COUNT(e.employee_id) > 5; 


Problem 55
Retrieve the employee ID(s) and number of jobs each employee has held for employees that have held more than 2 jobs. Provide an appropriate alias for the aggregation.

SELECT e.employee_id, COUNT(e.job_id) AS job_count
FROM employees AS e
GROUP BY e.employee_id
HAVING COUNT(e.job_id) > 2;


Problem 56
Retrieve employee IDs, job IDs, hire dates, and salaries for all employees. Sort/order the result set by hire date in ascending order and by salary in descending order.

SELECT e.employee_id, e.job_id, e.hire_date, e.salary 
FROM employees AS e
ORDER BY e.hire_date ASC, e.salary DESC;


Problem 57
Retrieve country IDs, country names, and region IDs for all countries. Sort/order the result set by region ID in ascending order and by country name in ascending order.

SELECT c.country_id, c.country_name, c.region_id 
FROM countries AS c
ORDER BY c.region_id ASC, c.country_name ASC;


Problem 58
Retrieve the employee ID and hire date for each employee. Sort/order the result set by hire date in ascending order (i.e., oldest to newest).

SELECT e.employee_id, e.hire_date
FROM employees AS e
ORDER BY e.hire_date ASC;


Problem 59
Retrieve the employee ID, job ID, and salary for each employee. Sort/order the result set by salary in descending order (i.e., largest salary to smallest salary).

SELECT e.employee_id, e.job_id, e.salary 
FROM employees AS e
ORDER BY e.salary DESC;


Problem 60
Retrieve the manager ID, employee ID, and salary for each employee. Sort/order the result set by manager ID (ascending) and within each manager, sort employee salaries in descending order.

SELECT e.manager_id, e.employee_id, e.salary
FROM employees AS e
ORDER BY e.manager_id ASC, e.salary DESC; 


Problem 61
For each country ID, return the number of departments/warehouses. Sort/order the result set by the number of departments/warehouses located in each country. Provide an appropriate alias for the aggregation.

SELECT l.country_id, COUNT(l.location_id) AS warehouse_count
FROM locations AS l
GROUP BY l.country_id
ORDER BY warehouse_count DESC;


Problem 62
Write a query that returns a result set containing, for each product, the product ID, product name, product description, list price, and minimum price.
In addition, include a derived column containing the difference between the listing price and the minimum price. Alias this column as “amount_above_min.”

SELECT p.product_id, p.product_name, p.product_description, p.list_price, p.min_price, p.list_price - p.min_price AS amount_above_min
FROM product_information AS p;


Problem 63
Write a query that returns a result set containing, for each customer, the customer ID, customer first name, 
customer last name, and credit limit. Only include customers with a last name starting with ‘A’ that also have a credit limit less than or equal to 1200. Sort the result set by credit limit, ascending.

SELECT c.customer_id, c.cust_first_name, c.cust_last_name, c.credit_limit
FROM customers AS c
WHERE c.cust_last_name LIKE 'A%' AND c.credit_limit <= 1200
ORDER BY c.credit_limit ASC;


Problem 64
Write a query that returns a result set containing, for each order, the order ID, order date, and order total. Only include orders placed in year 2008 and later 
with an order total greater than $50,000 or for those orders placed in year 2007 with an order total greater than $25,000. Sort the result set by order date (ascending) and by order total (descending).

SELECT o.order_id, o.order_date, o.order_total
FROM orders AS o
WHERE (YEAR(o.order_date)=2007 AND o.order_total>25000) OR (YEAR(o.oder_date)>=2008 AND o.order_total>50000)
ORDER BY o.order_date ASC, o.order_total DESC;

Problem 65
Write a query that returns a result set containing the number of customers for each gender and credit limit combination.
Gender and credit limit data should be included in the result set. Sort the result set by credit limit (ascending) and gender (ascending).

SELECT c.gender, COUNT(c.gender) AS gender_count, c.credit_limit
FROM customers AS c
GROUP BY c.gender, c.credit_limit
ORDER BY c.credit_limit ASC, c.gender ASC;

Problem 66
Write a query that returns a result set containing the number of customers for each natural language support territory (nls_territory), gender, and credit limit combination. NLS territory, gender, and credit limit data should be included in the result set. Only include those combinations for which a single customer is aligned/belongs. Sort the result set by NLS territory (ascending), credit limit (ascending), and gender (ascending).

SELECT  c.gender, c.credit_limit, COUNT(*) AS cust_count
FROM customers AS c
GROUP BY c.nls_territory, c.gender, c.credit_limit
HAVING COUNT(*) = 1
ORDER BY c.nls_territory ASC, c.credit_limit ASC, c.gender ASC;

*** NOTE: COUNT(*) AS cust_count: The function COUNT(*) counts the number of customers in each group. The alias cust_count makes it clear what this column represents.
          HAVING COUNT(*) = 1: This clause is used to filter the grouped results to include only those groups where exactly one customer is present, which aligns 
          with the requirement to include only combinations with a single customer.






























